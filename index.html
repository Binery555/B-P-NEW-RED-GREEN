<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Binance Futures Positions — 6M Trend Trades</title>
  <!-- Binance Plex Webfont -->
  <link href="https://db.onlinewebfonts.com/c/d05c19ccecf7003d248c60ffd6b5e8f7?family=Binance+PLEX" rel="stylesheet"/>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"/>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --panel-bg: #1e2127;
      --secondary-bg: #32383e;
      --btn-bg: #2f3339;
      --text-primary: #ffffff;
      --text-secondary: #7c828a;
      --text-green: #3acf87;
      --text-red: #e04b4a;
      --highlight: #f0b90b;
    }
    body {
      background-color: var(--panel-bg);
      color: #b0b0b0;
      font-family: 'Binance PLEX', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: flex; flex-direction: column;
      height: 100vh; max-width: 430px; margin: 0 auto;
    }
    .header-wrapper { display: flex; justify-content: center; margin-top: 12px; margin-bottom: 4px; background: var(--panel-bg); }
    .header-toggle { display: flex; background: var(--panel-bg); border-radius: 6px; overflow: hidden; width: 180px; height: 28px; }
    .header-toggle button { flex: 1; padding: 4px 6px; border: none; background: transparent; color: var(--text-secondary); font-size: 11px; cursor: pointer; }
    .header-toggle .active { background: var(--secondary-bg); color: var(--text-primary); font-weight: 500; }

    /* shifted left/right per your earlier layout */
    nav.main-nav, .sub-toggle, .section-toggle { transform: translateX(0.1cm); }
    nav.main-nav { display: flex; margin: 0 12px; background: var(--panel-bg); padding: 4px 0; }
    nav.main-nav a { margin-right: 16px; text-decoration: none; color: var(--text-secondary); font-size: 13px; padding: 8px 0; white-space: nowrap; }
    nav.main-nav a.active { color: var(--text-primary); font-weight: 500; }

    .sub-toggle { display: flex; margin: 8px 12px; background: var(--panel-bg); padding: 4px; border-radius: 4px; }
    .sub-toggle button { margin-right: 8px; padding: 5px 10px; background: var(--panel-bg); border: none; border-radius: 4px; color: var(--text-secondary); font-size: 12px; cursor: pointer; }
    .sub-toggle .active { background: var(--secondary-bg); color: var(--text-primary); }

    .section-toggle { display: flex; margin: 12px; background: var(--panel-bg); padding: 4px; border-radius: 4px; }
    .section-toggle div { margin-right: 16px; cursor: pointer; font-size: 13px; position: relative; color: var(--text-secondary); }
    .section-toggle .active { color: var(--text-primary); font-weight: 500; }
    .section-toggle .active::after { content: ''; position: absolute; bottom: -4px; left: 50%; transform: translateX(-50%); width: 20px; height: 2px; background: var(--highlight); }

    .feed { display: flex; flex-direction: column; gap: 8px; flex: 1; overflow-y: auto; padding: 0 12px; margin-bottom: 4px; background: var(--panel-bg); }
    .feed::-webkit-scrollbar { display: none; }

    /* Panels (frames removed) */
    .trade-panel { background: var(--panel-bg); padding: 12px; border-radius: 8px; border: none; box-shadow: none; }
    .trade-panel .header { display: flex; align-items: center; margin-bottom: 8px; }
    .icon-buy, .icon-sell {
      color: #fff; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center;
      font-size: 12px; font-weight: 700; margin-right: 8px; border-radius: 2px;
    }
    .icon-buy { background: var(--text-green); }
    .icon-sell { background: var(--text-red); }
    .symbol { font-size: 14px; font-weight: 500; margin-right: 6px; color: var(--text-primary); }
    .tag { background: var(--secondary-bg); color: var(--text-secondary); font-size: 10px; padding: 1px 4px; margin-right: 4px; text-transform: uppercase; border-radius: 3px; }
    .exclamations { display: flex; margin-left: 6px; }
    .exclamations span { position: relative; width: 2px; height: 10px; background: var(--secondary-bg); margin: 0 1px; border-radius: 1px; transition: background 0.3s ease; }
    .exclamations span::after { content: ''; position: absolute; bottom: -3px; left: 50%; transform: translateX(-50%); width: 2px; height: 2px; background: inherit; border-radius: 50%; }
    .exclamations span.green, .exclamations span.green::after { background: var(--text-green); }
    .share { margin-left: auto; color: var(--text-secondary); font-size: 16px; cursor: pointer; }

    .content-columns { display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 8px; gap: 8px; }
    .column { display: flex; flex-direction: column; }
    .column.right { text-align: right; }
    .stat { margin-bottom: 8px; }
    .label { font-size: 12px; color: var(--text-secondary); border-bottom: 1px dotted var(--text-secondary); padding-bottom: 2px; display: inline-block; }
    .label.no-line { border-bottom: none; }
    .value { font-size: 14px; font-weight: 400; color: var(--text-primary); transition: all 0.2s ease; }
    .value.green, .value.percent.green { color: var(--text-green); font-size: 18px; font-weight: 700; }
    .value.red, .value.percent.red { color: var(--text-red); font-size: 18px; font-weight: 700; }
    .margin-ratio-value { font-size: 12px !important; }

    .actions { display: flex; justify-content: space-between; gap: 8px; }
    .btn { flex: 1; background: var(--btn-bg); color: #fff; border: none; border-radius: 4px; padding: 6px 0; font-size: 12px; cursor: pointer; transition: background 0.3s; }
    .btn:hover { background: var(--secondary-bg); }
  </style>
</head>
<body>
  <div class="header-wrapper">
    <div class="header-toggle">
      <button class="active">Exchange</button>
      <button>Wallet</button>
    </div>
  </div>

  <nav class="main-nav">
    <a href="#" class="active">Overview</a>
    <a href="#">Funding</a>
    <a href="#futures">Futures</a>
    <a href="#">Spot</a>
  </nav>

  <div class="sub-toggle">
    <button class="active">USDⓈ-M</button>
    <button>COIN-M</button>
  </div>

  <div class="section-toggle">
    <div class="active">Positions</div>
    <div>Assets</div>
  </div>

  <!-- Entry Window UI removed -->

  <div class="feed"></div>

  <script>
    // ---------------------- Symbols to render ----------------------
    const seedSymbols = [
      'BTCUSDT','ETHUSDT','BNBUSDT','ADAUSDT','SOLUSDT','XRPUSDT','DOTUSDT','LTCUSDT',
      'LINKUSDT','DOGEUSDT','AAVEUSDT','SUSHIUSDT','SHIBUSDT','COMPUSDT','ETCUSDT','ZECUSDT',
      'XMRUSDT','LRCUSDT','QNTUSDT','CRVUSDT','UNIUSDT','BCHUSDT','XLMUSDT','ATOMUSDT',
      'MATICUSDT','AVAXUSDT','TRXUSDT','EOSUSDT','NEARUSDT','FILUSDT',
      'OPUSDT','ARBUSDT','APTUSDT','SUIUSDT','INJUSDT','RNDRUSDT','FTMUSDT','GALAUSDT',
      'THETAUSDT','SANDUSDT','MANAUSDT','AXSUSDT','CFXUSDT','ICPUSDT','LDOUSDT','PEPEUSDT',
      'FLOKIUSDT','WIFUSDT','ARKUSDT','IOTAUSDT','KASUSDT','PYTHUSDT','STRKUSDT','JUPUSDT',
      'APEUSDT','BLURUSDT','SEIUSDT','TIAUSDT','TONUSDT','ONDOUSDT'
    ];

    // ---------------------- Utility & formatting ----------------------
    const numberWithCommas = (x) => String(x).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    const toFixedSafe = (n, dp) => {
      const num = Number(n);
      if (!Number.isFinite(num)) return (0).toFixed(dp);
      const m = Math.pow(10, dp);
      return (Math.round(num * m) / m).toFixed(dp);
    };
    const dpFromTick = (tickStr) => {
      const idx = (tickStr || '').indexOf('.');
      if (idx === -1) return 0;
      return tickStr.length - idx - 1;
    };
    const quantizeToTick = (price, tickSize) => {
      const step = parseFloat(tickSize);
      if (!isFinite(price) || !isFinite(step) || step <= 0) return price;
      return Math.round(price / step) * step;
    };
    const quantizeDownToStep = (qty, stepSize) => {
      const step = parseFloat(stepSize);
      if (!isFinite(qty) || !isFinite(step) || step <= 0) return qty;
      return Math.floor(qty / step) * step;
    };
    function joinIntDec(i, d) {
      const I = numberWithCommas(i);
      return d !== undefined ? I + '.' + d : I;
    }

    // ---------------------- Market meta (tick & step sizes) ----------------------
    const marketMeta = Object.create(null);
    let metaLoaded = false;
    async function loadExchangeMeta() {
      if (metaLoaded) return;
      const url = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
      const res = await fetch(url);
      const json = await res.json();
      if (!json || !Array.isArray(json.symbols)) return;

      for (const s of json.symbols) {
        const sym = s.symbol;
        if (!seedSymbols.includes(sym)) continue;
        let tickSize = '0.01';
        let stepSize = '0.001';
        let minQty = 0;

        if (Array.isArray(s.filters)) {
          for (const f of s.filters) {
            if (f.filterType === 'PRICE_FILTER' && f.tickSize) tickSize = f.tickSize;
            if ((f.filterType === 'LOT_SIZE' || f.filterType === 'MARKET_LOT_SIZE') && f.stepSize) stepSize = f.stepSize;
            if ((f.filterType === 'LOT_SIZE' || f.filterType === 'MARKET_LOT_SIZE') && f.minQty) minQty = parseFloat(f.minQty) || 0;
          }
        }

        marketMeta[sym] = {
          tickSize,
          stepSize,
          minQty,
          priceDp: dpFromTick(tickSize)
        };
      }
      metaLoaded = true;
    }
    const getMeta = (sym) => marketMeta[sym] || { tickSize: '0.01', stepSize: '0.001', minQty: 0, priceDp: 2 };
    function formatPrice(sym, x) {
      const m = getMeta(sym);
      const q = quantizeToTick(x, m.tickSize);
      const s = toFixedSafe(q, m.priceDp);
      const [i, d] = s.split('.');
      return joinIntDec(i, d);
    }
    // PNL must be EXACTLY 2 decimals globally
    function formatProfit(_sym, x) {
      const s = toFixedSafe(x, 2);
      const [i, d] = s.split('.');
      return joinIntDec(i, d);
    }
    function formatTwoDP(x) {
      const s = toFixedSafe(x, 2);
      const [i, d] = s.split('.');
      return joinIntDec(i, d);
    }

    // ---------------------- Maintenance Margin Rates (simple map) ----------------------
    const maintenanceMarginRates = {
      BTCUSDT: 0.004, ETHUSDT: 0.005, BNBUSDT: 0.005, ADAUSDT: 0.010, SOLUSDT: 0.008, XRPUSDT: 0.010,
      DOTUSDT: 0.010, LTCUSDT: 0.010, LINKUSDT: 0.010, DOGEUSDT: 0.012, AAVEUSDT: 0.010, SUSHIUSDT: 0.015,
      SHIBUSDT: 0.020, COMPUSDT: 0.010, ETCUSDT: 0.010, ZECUSDT: 0.015, XMRUSDT: 0.020, LRCUSDT: 0.020,
      QNTUSDT: 0.015, CRVUSDT: 0.020, UNIUSDT: 0.010, BCHUSDT: 0.010, XLMUSDT: 0.015, ATOMUSDT: 0.010,
      MATICUSDT: 0.010, AVAXUSDT: 0.010, TRXUSDT: 0.020, EOSUSDT: 0.015, NEARUSDT: 0.020, FILUSDT: 0.015,
      OPUSDT: 0.015, ARBUSDT: 0.020, APTUSDT: 0.015, SUIUSDT: 0.020, INJUSDT: 0.015, RNDRUSDT: 0.015,
      FTMUSDT: 0.020, GALAUSDT: 0.025, THETAUSDT: 0.020, SANDUSDT: 0.020, MANAUSDT: 0.020, AXSUSDT: 0.020,
      CFXUSDT: 0.025, ICPUSDT: 0.015, LDOUSDT: 0.020, PEPEUSDT: 0.030, FLOKIUSDT: 0.030, WIFUSDT: 0.030,
      ARKUSDT: 0.020, IOTAUSDT: 0.020, KASUSDT: 0.025, PYTHUSDT: 0.020, STRKUSDT: 0.020, JUPUSDT: 0.020,
      APEUSDT: 0.020, BLURUSDT: 0.020, SEIUSDT: 0.020, TIAUSDT: 0.020, TONUSDT: 0.015, ONDOUSDT: 0.020
    };
    const getMaintRate = (sym) => maintenanceMarginRates[sym] ?? 0.01;

    // ---------------------- Settings ----------------------
    let symbols = seedSymbols.slice();
    const tradeCount = 40; // number of mock positions to render
    const feedDiv = document.querySelector('.feed');

    // Fixed entry window (months)
    const ENTRY_MONTHS = 6;
    const JITTER_DAYS = 5; // entry shifts ±5d on each refresh

    // ---------------------- Core calcs (Linear USDT, Cross) ----------------------
    const qtyFrom = (marginUsed, leverage, entry) => (leverage * marginUsed) / entry;
    const upnlLong  = (mark, entry, qty) => (mark - entry) * qty;
    const upnlShort = (mark, entry, qty) => (entry - mark) * qty;
    const roiPct = (pnl, usedMargin) => (pnl / usedMargin) * 100;
    const maintenance = (mmr, mark, qty) => mmr * mark * qty;
    const marginBalance = (effectiveMargin, uPnL) => effectiveMargin + uPnL;

    function liqPriceLong(entry, leverage, mmr, marginUsed, effectiveMargin) {
      const Q = (leverage * marginUsed) / entry;
      const denom = Q * (1 - mmr);
      const num = Q * entry - effectiveMargin;
      if (denom <= 0) return null;
      const P = num / denom;
      if (!isFinite(P) || P <= 0) return null;
      return P;
    }
    function liqPriceShort(entry, leverage, mmr, marginUsed, effectiveMargin) {
      const Q = (leverage * marginUsed) / entry;
      const denom = Q * (1 + mmr);
      const num = effectiveMargin + Q * entry;
      if (denom <= 0) return null;
      const P = num / denom;
      if (!isFinite(P) || P <= 0) return null;
      return P;
    }
    const marginRatioPct = (maint, mBal) => (mBal <= 0 ? 100 : (maint / mBal) * 100);

    // ---------------------- UI helpers ----------------------
    const meterBars = () => {
      const totalBars = 4; const greenBars = Math.floor(Math.random() * totalBars) + 1;
      let html = '';
      for (let j = 0; j < totalBars; j++) html += `<span class="${j < greenBars ? 'green' : ''}"></span>`;
      return html;
    };

    // Build one trade panel element (trend tag removed)
    function createPanel({ sym, leverage, entry, mark, usedMargin, effMargin, mmr, qty, notionalUSDT, side, modeLabel }) {
      const pnl = side === 'LONG' ? upnlLong(mark, entry, qty) : upnlShort(mark, entry, qty);
      const roi = roiPct(pnl, usedMargin);
      const maint = maintenance(mmr, mark, qty);
      const mBal = marginBalance(effMargin, pnl);
      const mRatio = marginRatioPct(maint, mBal);
      const liq = side === 'LONG'
        ? liqPriceLong(entry, leverage, mmr, usedMargin, effMargin)
        : liqPriceShort(entry, leverage, mmr, usedMargin, effMargin);

      const sideIcon = side === 'LONG' ? `<span class="icon-buy">B</span>` : `<span class="icon-sell">S</span>`;

      const panel = document.createElement('div');
      panel.className = 'trade-panel';
      panel.innerHTML = `
        <div class="header">
          ${sideIcon}
          <span class="symbol">${sym}</span>
          <span class="tag">PERP</span>
          <span class="tag">${modeLabel} ${leverage}×</span>
          <span class="exclamations">${meterBars()}</span>
          <i class="fas fa-share-alt share"></i>
        </div>
        <div class="content-columns">
          <div class="column">
            <div class="stat">
              <div class="label">PNL (USDT)</div>
              <div class="value pnl ${pnl < 0 ? 'red' : 'green'}">${formatProfit(sym, pnl)}</div>
            </div>
            <div class="stat">
              <div class="label">Size (USDT)</div>
              <div class="value size">${formatTwoDP(notionalUSDT)}</div>
            </div>
            <div class="stat">
              <div class="label">Entry Price (USDT)</div>
              <div class="value entry">${formatPrice(sym, entry)}</div>
            </div>
          </div>
          <div class="column center">
            <div class="stat">
              <div class="label no-line">Margin (USDT)</div>
              <div class="value margin">${formatTwoDP(usedMargin)}</div>
            </div>
            <div class="stat">
              <div class="label no-line">Mark Price (USDT)</div>
              <div class="value mark">${formatPrice(sym, mark)}</div>
            </div>
          </div>
          <div class="column right">
            <div class="stat">
              <div class="label">ROI</div>
              <div class="value percent roi ${roi < 0 ? 'red' : 'green'}">${(roi >= 0 ? '+' : '') + toFixedSafe(roi, 2)}%</div>
            </div>
            <div class="stat margin-ratio">
              <div class="label">Margin Ratio</div>
              <div class="value percent margin-ratio-value ${mRatio >= 80 ? 'red' : 'green'}">${toFixedSafe(mRatio, 2)}%</div>
            </div>
            <div class="stat">
              <div class="label no-line">Liq. Price (USDT)</div>
              <div class="value liq">${liq === null ? '—' : formatPrice(sym, liq)}</div>
            </div>
          </div>
        </div>
        <div class="actions">
          <button class="btn">Leverage</button>
          <button class="btn">TP/SL</button>
          <button class="btn">Close</button>
          <button class="btn">Reverse</button>
        </div>`;

      return { node: panel, sym, leverage, mmr, entry, usedMargin, effMargin, qty, mark, side };
    }

    // Recompute & render a trade object
    function renderTrade(t) {
      const pnl = (t.side === 'LONG') ? upnlLong(t.mark, t.entry, t.qty) : upnlShort(t.mark, t.entry, t.qty);
      const roi = roiPct(pnl, t.usedMargin);
      const maintV = maintenance(t.mmr, t.mark, t.qty);
      const mBal = marginBalance(t.effMargin, pnl);
      const mRatio = marginRatioPct(maintV, mBal);
      const liq = (t.side === 'LONG')
        ? liqPriceLong(t.entry, t.leverage, t.mmr, t.usedMargin, t.effMargin)
        : liqPriceShort(t.entry, t.leverage, t.mmr, t.usedMargin, t.effMargin);

      const pnlEl = t.node.querySelector('.value.pnl');
      pnlEl.textContent = formatProfit(t.sym, pnl); // ALWAYS 2dp
      pnlEl.classList.toggle('green', pnl >= 0);
      pnlEl.classList.toggle('red', pnl < 0);

      t.node.querySelector('.value.mark').textContent = formatPrice(t.sym, t.mark);

      const roiEl = t.node.querySelector('.value.roi');
      roiEl.textContent = (roi >= 0 ? '+' : '') + toFixedSafe(roi, 2) + '%';
      roiEl.classList.toggle('green', roi >= 0);
      roiEl.classList.toggle('red', roi < 0);

      const mrEl = t.node.querySelector('.value.margin-ratio-value');
      mrEl.textContent = toFixedSafe(mRatio, 2) + '%';
      mrEl.classList.toggle('green', mRatio < 80);
      mrEl.classList.toggle('red', mRatio >= 80);

      const liqEl = t.node.querySelector('.value.liq');
      liqEl.textContent = (liq === null) ? '—' : formatPrice(t.sym, liq);
    }

    // ---------------------- Entry fetch helpers (fixed 6M with jitter) ----------------------
    function monthsAgoMs(months) {
      const d = new Date();
      d.setMonth(d.getMonth() - months);
      d.setHours(0, 0, 0, 0);
      return d.getTime();
    }

    async function fetchWindowEntryClose(sym, months, jitterDays = 5) {
      const base = monthsAgoMs(months);
      const delta = (Math.floor(Math.random() * (2 * jitterDays + 1)) - jitterDays) * 24 * 3600 * 1000;
      const startMs = base + delta;

      const tryEndpoints = [
        `https://fapi.binance.com/fapi/v1/markPriceKlines?symbol=${sym}&interval=1d&startTime=${startMs - 2*24*3600*1000}&limit=2`,
        `https://fapi.binance.com/fapi/v1/continuousKlines?pair=${sym}&contractType=PERPETUAL&interval=1d&startTime=${startMs - 2*24*3600*1000}&limit=2`,
        `https://fapi.binance.com/fapi/v1/klines?symbol=${sym}&interval=1d&startTime=${startMs - 2*24*3600*1000}&limit=2`
      ];

      for (const url of tryEndpoints) {
        try {
          const res = await fetch(url);
          if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data) && data.length > 0) {
              const k = data[0];
              const close = parseFloat(k[4]);
              if (isFinite(close)) return close;
            }
          }
        } catch(e) {}
      }
      return null;
    }

    async function loadEntryMap(symbolList, months) {
      const entryMap = Object.create(null);
      const unique = [...new Set(symbolList)];
      const batch = 8; // limit concurrency
      for (let i = 0; i < unique.length; i += batch) {
        const chunk = unique.slice(i, i + batch);
        await Promise.all(chunk.map(async (sym) => {
          const close = await fetchWindowEntryClose(sym, months, JITTER_DAYS);
          if (isFinite(close)) entryMap[sym] = close;
        }));
      }
      return entryMap;
    }

    // ---------------------- Live init + speed-synced updates ----------------------
    let trades = [];
    let ws = null;

    async function seedWithFuturesMarks(months) {
      await loadExchangeMeta();
      symbols = symbols.filter(s => !!marketMeta[s]);

      // Snapshot of current marks
      const url = 'https://fapi.binance.com/fapi/v1/premiumIndex';
      const res = await fetch(url);
      const arr = await res.json();
      const markMap = Object.create(null);
      arr.forEach(o => { if (o && o.symbol) markMap[o.symbol] = parseFloat(o.markPrice); });

      // We'll only need entries for the first N symbols we will render
      const plannedSyms = [];
      for (let i = 0; i < tradeCount; i++) plannedSyms.push(symbols[i % symbols.length]);
      const entryMap = await loadEntryMap(plannedSyms, months);

      const newTrades = [];
      const feedDiv = document.querySelector('.feed');
      feedDiv.innerHTML = '';

      for (let i = 0; i < tradeCount; i++) {
        const sym = symbols[i % symbols.length];
        const liveMark = markMap[sym];
        if (!isFinite(liveMark)) continue;

        const entryRaw = entryMap[sym];
        if (!isFinite(entryRaw)) continue;

        const leverage = [10, 20, 50, 100][Math.floor(Math.random() * 4)];

        // Entry = close from selected window, quantized to tick
        const entry = quantizeToTick(entryRaw, getMeta(sym).tickSize);

        // Direction so that window trend "wins": if market went up -> LONG; if down -> SHORT
        const side = (liveMark >= entry) ? 'LONG' : 'SHORT';

        const usedMargin = 50 + Math.random() * 950; // 50-1000 USDT
        const m = getMeta(sym);

        let qtyRaw = qtyFrom(usedMargin, leverage, entry);
        let qty = quantizeDownToStep(qtyRaw, m.stepSize);
        if (qty < m.minQty) qty = m.minQty;

        const notionalUSDT = entry * qty;
        const effMargin = usedMargin * (1.5 + Math.random() * 2.5); // simulate wallet balance impact for margin ratio
        const mmr = getMaintRate(sym);

        const panelState = createPanel({
          sym, leverage, entry, mark: liveMark, usedMargin, effMargin, mmr,
          qty, notionalUSDT, side, modeLabel: 'Cross'
        });
        newTrades.push(panelState);
        feedDiv.appendChild(panelState.node);
      }

      trades = newTrades; // swap atomically so WS uses the latest list
    }

    function connectFuturesMarkWS() {
      const WS_URL = 'wss://fstream.binance.com/ws/!markPrice@arr';
      if (ws) { try { ws.close(); } catch {} ws = null; }
      ws = new WebSocket(WS_URL);

      ws.onopen = () => console.log('[WS] Connected to Futures mark price stream');

      ws.onmessage = (evt) => {
        let data;
        try { data = JSON.parse(evt.data); } catch { return; }
        if (!Array.isArray(data)) return;

        for (const o of data) {
          const sym = o.s;
          const priceStr = o.p; // mark price string
          if (!sym || priceStr === undefined) continue;
          const mp = parseFloat(priceStr);
          if (!isFinite(mp)) continue;

          for (const t of trades) {
            if (t.sym === sym) {
              t.mark = mp; // Binance live push
              renderTrade(t);
            }
          }
        }
      };

      ws.onclose = (e) => {
        console.warn('[WS] Closed. Reconnecting in 2s...', e.code, e.reason);
        setTimeout(connectFuturesMarkWS, 2000);
      };
      ws.onerror = (err) => {
        console.error('[WS] Error', err);
        try { ws.close(); } catch {}
      };
    }

    (async function init() {
      try {
        await seedWithFuturesMarks(ENTRY_MONTHS); // fixed 6M; entry jitters each reload
        connectFuturesMarkWS();                   // live mark updates
      } catch (e) {
        console.error('Init failed:', e);
      }
      // Expose for dev
      window.trades = trades;
    })();
  </script>
</body>
</html>
